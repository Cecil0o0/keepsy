# Why choose Zig rather than C++/Rust/Go/TypeScript?

## Summary

As annouced by zig orgnization that it is a small simple language product with no hidden control flow, no hidden allocations, it means we could and should focus on debugging our application rather than the knowledge of programming language. Based on that our users also could choose both performance and safety for application development with the powerful comprehensive comptime optimization implemented by native compiler.
正如 zig 组织宣称的那样它是一门小巧简单的语言产品，没有隐藏控制流，没有隐藏内存分配，这意味着我们能够聚焦于调试我们的应用程序而不是编程语言知识。基于此我们用户也能够在应用程序开发中同时选择性能和安全性，通过由原生编译器实施的强大全面的编译时优化。

## Motivation

To start up with a storage layer for big data, stability is the first vital factor and commitment for our future users so that we need an absolutely low-level safe programming language for implementations of project. C++ is [unsafe by default](https://safecpp.org/draft.html#:~:text=C%2B%2B%E2%80%99s%20are%20unsafe%20by%20default), Rust costs too much to achieve safety with [ownership mechanism](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html), Go has an extra runtime costs with [GC](https://tip.golang.org/doc/gc-guide#Understanding_costs).
去起始于一个大数据存储层，稳定性是首要关键要素以及对我们未来用户的承诺因此我们需要一个绝对底层安全的编程语言用以项目实施。C++ [默认是不安全的](https://safecpp.org/draft.html#:~:text=C%2B%2B%E2%80%99s%20are%20unsafe%20by%20default)，Rust 使用[所有权机制](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)实现安全的成本太高，Go 由于[垃圾回收](https://tip.golang.org/doc/gc-guide#Understanding_costs)拥有额外运行时开销。

A decentralized community structure can offer significant benefits to a programming language, fostering its growth, resilience, and long-term health. So as [Zig's community](https://github.com/ziglang/zig/wiki/Community).
一个去中心化社区结构能够为编程语言提供显著的好处，促进其发展、韧性和长期的健康。[Zig 社区](https://github.com/ziglang/zig/wiki/Community)就是如此。


## Detailed Explanation

{{Describe the expected changes in detail, }}

## Rationale and Alternatives

{{Discuss 2-3 different alternative solutions that were considered. This is required, even if it seems like a stretch. Then explain why this is the best choice out of available ones.}}

## Implementation

{{Give a high-level overview of implementation requirements and concerns. Be specific about areas of code that need to change, and what their potential effects are. Discuss which repositories and sub-components will be affected, and what its overall code effect might be.}}

{{THIS SECTION IS REQUIRED FOR RATIFICATION -- you can skip it if you don't know the technical details when first submitting the proposal, but it must be there before it's accepted}}

## Prior Art

{{This section is optional if there are no actual prior examples in other tools}}

{{Discuss existing examples of this change in other tools, and how they've addressed various concerns discussed above, and what the effect of those decisions has been}}

## Unresolved Questions and Bikeshedding

{{Write about any arbitrary decisions that need to be made (syntax, colors, formatting, minor UX decisions), and any questions for the proposal that have not been answered.}}

{{THIS SECTION SHOULD BE REMOVED BEFORE RATIFICATION}}
