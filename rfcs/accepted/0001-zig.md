# Why choose zig rather than C++/Rust/Go?

## Summary

As zig annouced that it is a small simple language with no hidden control flow, but we still could choose both performance and safety with a powerful out-of-box comptime optimization, it means we could focus on debugging our application but not the knowledge of programming language.
正如 zig 宣称的那样它是一门小巧简单的语言，没有隐藏控制流，但是我们仍旧能够同时选择性能和安全性通过强大的开箱即用的编译时优化，这意味着我们能够聚焦于调试我们的应用程序而不是编程语言知识。

## Motivation

To start up with a storage layer for big data, stability is the first vital factor and commitment for our future users so that we need a absolutely low-level safe programming language for the implementation. C++ is [unsafe by default](https://safecpp.org/draft.html#:~:text=C%2B%2B%E2%80%99s%20are%20unsafe%20by%20default), Rust costs too much to achieve safety with [ownership mechanism](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html), Go has a relatively slow start-up timing with [GC](https://tip.golang.org/doc/gc-guide#Understanding_costs).
去起始于一个大数据存储层，稳定性是首要关键要素以及对我们未来用户的承诺因此我们需要一个绝对底层安全的编程语言用以实施。C++ [默认是不安全的](https://safecpp.org/draft.html#:~:text=C%2B%2B%E2%80%99s%20are%20unsafe%20by%20default)，Rust 使用[所有权机制](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)实现安全的成本太高，Go 由于[垃圾回收](https://tip.golang.org/doc/gc-guide#Understanding_costs)拥相对缓慢。

The implementation would like to offer a lakehouse storage layer as a robust optimal software for big data to user for ETL job, BI and anything about data processing on a editor or IDE. We expected the product will achieve goals of popularity and sustainibility with software engineering and zig programming language.
此实施将会提供一个湖仓存储层作为健壮且最优大数据软件给用户基于编辑器或是 IDE 做 ETL 任务、商业智能或是有关数据加工的任意事宜。我们预期产品将通过软件工程与 zig 编程语言实现流行且可持续的目标。

## Detailed Explanation

{{Describe the expected changes in detail, }}

## Rationale and Alternatives

{{Discuss 2-3 different alternative solutions that were considered. This is required, even if it seems like a stretch. Then explain why this is the best choice out of available ones.}}

## Implementation

{{Give a high-level overview of implementation requirements and concerns. Be specific about areas of code that need to change, and what their potential effects are. Discuss which repositories and sub-components will be affected, and what its overall code effect might be.}}

{{THIS SECTION IS REQUIRED FOR RATIFICATION -- you can skip it if you don't know the technical details when first submitting the proposal, but it must be there before it's accepted}}

## Prior Art

{{This section is optional if there are no actual prior examples in other tools}}

{{Discuss existing examples of this change in other tools, and how they've addressed various concerns discussed above, and what the effect of those decisions has been}}

## Unresolved Questions and Bikeshedding

{{Write about any arbitrary decisions that need to be made (syntax, colors, formatting, minor UX decisions), and any questions for the proposal that have not been answered.}}

{{THIS SECTION SHOULD BE REMOVED BEFORE RATIFICATION}}